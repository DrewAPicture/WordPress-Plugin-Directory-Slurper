#!/usr/bin/php
<?php
$args = $argv;
$cmd = array_shift( $args );

$type = 'all';
if ( !empty( $args[0] ) ) {
	$type = $args[0];
}

switch ( $type ) {
	case 'readme':
		$directory = 'readmes';
		$download = 'readmes/%s.readme';
		$url = 'http://plugins.svn.wordpress.org/%s/trunk/readme.txt';
		break;
	case 'all':
		$directory = 'plugins';
		$download = 'zips/%s.zip';
		$url = 'http://downloads.wordpress.org/plugin/%s.latest-stable.zip?nostats=1';
		break;
	default:
		echo $cmd . ": invalid command\r\n";
		echo 'Usage: php ' . $cmd . " [command]\r\n\r\n";
		echo "Available commands:\r\n";
		echo "  all - Downloads full plugin zips\r\n";
		echo "  readme - Downloads plugin readmes only\r\n";
		die();
}

// Number of revisions to update per batch.
$per_batch = 1000;
if ( ! empty( $args[1] ) ) {
	if ( 0 == $per_batch = abs( intval( $args[1] ) ) ) {
		$per_batch = 1000;
	}
}

echo "Determining most recent SVN revision...\r\n";
try {
	$changelog = @file_get_contents( 'http://plugins.trac.wordpress.org/log/?format=changelog&stop_rev=HEAD' );
	if ( !$changelog )
		throw new Exception( 'Could not fetch the SVN changelog' );
	preg_match( '#\[([0-9]+)\]#', $changelog, $matches );
	if ( !$matches[1] )
		throw new Exception( 'Could not determine most recent revision.' );
} catch ( Exception $e ) {
	die( $e->getMessage() . "\r\n" );
}
$svn_last_revision = (int) $matches[1];
echo "Most recent SVN revision: " . $svn_last_revision . "\r\n";
if ( file_exists( $directory . '/.last-revision' ) ) {
	$last_revision = (int) file_get_contents( $directory . '/.last-revision' );
	echo "Last synced revision: " . $last_revision . "\r\n";
} else {
	$last_revision = false;
	echo "You have not yet performed a successful sync. Settle in. This will take a while.\r\n";
}

$start_time = time();

if ( $last_revision != $svn_last_revision ) {

	// Grab plugins for a first-time pull, get the count.
	if ( false === $last_revision ) {
		$plugins = file_get_contents( 'http://svn.wp-plugins.org/' );
		preg_match_all( '#<li><a href="([^/]+)/">([^/]+)/</a></li>#', $plugins, $matches );
		$total_plugins = $matches[1];
	}

	// Make copies of the original revision numbers for updating based on revision number.
	$temp_last_revision     = $last_revision;
	$temp_svn_last_revision = $svn_last_revision;

	// For first-time slurps, the difference is the total number of plugins.
	$difference = ( false === $last_revision ) ? count( $total_plugins ) : $svn_last_revision - $last_revision;

	// Determine the batch total based on the difference.
	$batch_total = ( $difference >= $per_batch ) ? $difference / $per_batch : 1;

	$plugins_count = 0;

	/*
	 * Display a message notifying that the plugins will be updated in batches.
	 * Not shown for first-time pulls.
	 */
	if ( $batch_total > 1 && false !== $last_revision ) {
		$display_diff = number_format( $difference );
		echo "The number of revisions to update is $display_diff. Updating in batches.\r\n";
	}

	$current_batch = 1;

	while( $current_batch <= $batch_total ) {
		if ( $batch_total > 1 ) {

			// Only increment the revision for batches 2+.
			if ( $current_batch > 1 ) {
				$temp_svn_last_revision = $temp_last_revision + $per_batch;
			}

			// Output batch message(s).
			if ( false !== $last_revision ) {
				// Updating from last revision.
				printf( "\r\n" . 'Updating batch %1$s of %2$d at r%3$s' . "\r\n\r\n",
					$current_batch,
					ceil( $batch_total ),
					$temp_svn_last_revision
				);
			} else {
				// First-time pull.
				printf( "\r\n" . 'Updating batch %1$s of %2$d' . "\r\n\r\n",
					$current_batch,
					ceil( $batch_total )
				);
			}

			if ( false === $last_revision ) {
				echo $current_batch . "\r\n";

				$offset = $current_batch == 1 ? 0 : $per_batch * ( $current_batch - 1 );

				echo $offset . "\r\n";
				echo count( $total_plugins) . "\r\n";

				$plugins = array_slice( $total_plugins, $offset, $per_batch );

				echo count( $plugins) . "\r\n";
			}
		}

		// Get the current batch's plugins for updating based on revision.
		if ( false !== $last_revision ) {
			$limit         = $batch_total > 1 ? $per_batch : $difference;
			$changelog_url = sprintf( 'http://plugins.trac.wordpress.org/log/?verbose=on&mode=follow_copy&format=changelog&rev=%d&limit=%d', $temp_svn_last_revision, $limit );
			$changes       = file_get_contents( $changelog_url );

			preg_match_all( '#^' . "\t" . '*\* ([^/A-Z ]+)[ /].* \((added|modified|deleted|moved|copied)\)' . "\n" . '#m', $changes, $matches );

			$plugins = array_unique( $matches[1] );
		}

		// Update plugins.
		foreach ( $plugins as $plugin ) {
			$plugin = urldecode( $plugin );

			echo "Updating " . $plugin;

			$output = null; $return = null;
			exec( 'wget -q -np -O ' . escapeshellarg( sprintf($download, $plugin) ) . ' ' . escapeshellarg( sprintf($url, $plugin) ) . ' > /dev/null', $output, $return );

			if ( $return === 0 && file_exists( sprintf($download, $plugin) ) ) {
				if ($type === 'all') {
					if ( file_exists( 'plugins/' . $plugin ) )
						exec( 'rm -rf ' . escapeshellarg( 'plugins/' . $plugin ) );

					exec( 'unzip -o -d plugins ' . escapeshellarg( 'zips/' . $plugin . '.zip' ) );
					exec( 'rm -rf ' . escapeshellarg( 'zips/' . $plugin . '.zip' ) );
				}
			} else {
				echo '... download failed.';
			}
			echo "\r\n";
		}

		// Handle incrementing the last revision and current batch number for batches 2+.
		if ( $batch_total > 1 ) {

			/*
			 * Print cleanup or error messages at the end of the current batch. Provides a closer
			 * starting place for non-first-pull updates if for some reason it hangs while updating.
			 */
			if ( false === $last_revision || ( false !== $last_revision && $batch_total == 1 ) ) {
				$new_revision = $svn_last_revision;
			} else {
				$new_revision = $temp_last_revision;
			}

			if ( false !== $last_revision ) {
				if ( file_put_contents( $directory . '/.last-revision', $new_revision ) ) {
					echo "[CLEANUP] Updated $directory/.last-revision to " . $new_revision . "\r\n";
				} else {
					echo "[ERROR] Could not update $directory/.last-revision to " . $new_revision . "\r\n";
				}
			}

			// Increment the revision number for the next batch based on the $per_batch value.
			if ( $batch_total > 1 && false !== $last_revision ) {
				$temp_last_revision = $temp_last_revision + $per_batch;
			}

			// Increment the batch number.
			$current_batch++;
		}

		// Add on the number of newly-updated plugins to the total count for the current batch.
		$plugins_count = count( $plugins ) + $plugins_count;
	}

	if ( false === $last_revision ) {
		if ( file_put_contents( $directory . '/.last-revision', $new_revision ) ) {
			echo "[CLEANUP] Updated $directory/.last-revision to " . $new_revision . "\r\n";
		} else {
			echo "[ERROR] Could not update $directory/.last-revision to " . $new_revision . "\r\n";
		}
	}
}

$end_time = time();
$minutes = ( $end_time - $start_time ) / 60;
$seconds = ( $end_time - $start_time ) % 60;

echo "[SUCCESS] Done updating plugins!\r\n";
echo "It took " . number_format( $minutes ) . " minute" . ( $minutes == 1 ? '' : 's' ) . " and " . $seconds . " second" . ( $seconds == 1 ? '' : 's' ) . " to update ". $plugins_count  ." plugin" . ( $plugins_count == 1 ? '' : 's') . "\r\n";
echo "[DONE]\r\n";
